import numpy as np
import iris_data as iris
import matplotlib.pyplot as plt
import random
import copy

train_data = iris.give_train()
train_data = train_data + iris.give_test()
#print(train_data)

class myNeuron():
	def __init__(self, V=-65, u=-13, a=0.02, b=0.2, c=-65, d=4,  I=0, jF = False, exin = 1): 
		self.a = a
		self.b = b
		self.c = c
		self.d = d
		self.V = V
		self.u = u
		self.I = I
		self.jF = jF
		self.exin = exin

num_neurons = 20
num_models = 50
num_samps = 20
num_gens = 50
num_mutate = 10
max_volt = 50
sim_length = 300
look_back_insuf = 5



curr_mult = 30
exin_array = [1, 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1]
ModBrain = [[0.0,33.13639527943026,23.431551125818366,30.651081933008385,9.652634787056572,21.078501991962902,17.614668239089305,40.4141875511971,21.069175028420194,19.671975738729138,17.800903977327124,20.288173331161122,18.44284924266026,20.585016479025825,17.04455792664548,22.315657895868185,18.47558417125017,20.066398979424356,39.200474363521835,17.890519135184],[26.524430045288078,0.0,18.31566646548282,25.068492224828752,15.229378306620546,16.444595366852603,22.464180570988255,23.432218679711163,23.87907302136944,20.86678555611249,21.729288363750687,26.67932985535743,23.74298796514052,20.232089424808898,24.392190425362237,21.35894856412221,23.179241425193446,37.33825161724029,18.637033661537085,20.398539373733474],[27.37538495133699,24.109454242234193,0.0,22.368674929156448,8.444477596403418,16.675144478114483,27.766601258743698,31.115601467111393,27.892371503599236,27.619655652815872,26.854906774458943,28.587846776811517,26.75013871764523,25.155821203250042,30.48654714705691,36.116615163627685,30.131284745307614,23.83474942791667,14.082457393339277,43.58797698579045],[28.966852970631443,14.29534075137925,27.380890892185825,0.0,25.819061216108416,20.00207149248721,16.446164744071687,17.524318944048034,16.715392225688774,21.24932495126589,17.64802592190621,19.135548272183996,16.844598784483242,20.11669672297193,21.64735032631613,21.32191380923467,19.060913673623332,17.528400849091547,15.484739081129803,25.53788008723752],[26.216729328517037,28.271436766643667,27.67725450436963,40.77470733505964,0.0,27.040446277157685,28.314200535755496,18.89043249688884,33.91867220764696,25.850744823634642,28.2033890503183,26.2174281931189,27.315031737722762,28.529530071320515,26.736975027031658,15.65513628635474,32.911055708887446,27.27902669396834,35.21513729527503,19.799074545343647],[25.573696750037833,28.282708073263912,28.658333664294005,36.10848694150578,29.849196587545727,0.0,29.731447791462855,27.500009631934862,25.50845499953142,24.671737306485884,28.196734654806463,25.599281641715475,24.703766798042132,25.39911961291167,40.174928808272206,23.740528570296803,26.252876507421767,20.84726066211808,28.748437719515948,30.342021118118456],[20.746149550164684,26.55046154929478,20.497824272971783,19.80237547911413,29.522569452329808,25.389742837271704,0.0,19.730240704936627,26.902997637867983,24.464118875709275,23.15954058615216,25.30027141994813,22.307409745326332,28.324345904172407,27.0486008164657,24.734903636194282,24.96831404379021,22.02379236470442,21.761826766292888,23.53758699330173],[25.200768500737325,26.09970575632272,29.630906356069403,25.657459848355607,29.3628700747622,32.54135344503054,22.031377166054355,0.0,25.871216413159672,22.91860560757471,24.193739272873206,19.3437289315036,23.84295611061755,21.587272393989377,19.41261990272548,25.761083605921932,29.94438270352618,25.5377105217439,29.724920260564808,26.383310236201844],[19.170635588183593,26.948537154408324,25.709014530821996,22.582888067192343,21.843966033062678,24.398015245447997,25.967396106738075,21.88872626246649,0.0,21.527489534572844,22.908181237650144,23.930134835248673,25.395479042980483,20.82058522337102,26.400142789550873,21.116072757122225,27.122549662231428,24.23393039496449,24.40164434884558,26.005252235445194],[31.34065637717063,26.04266834051254,25.293646133019482,27.732706500562088,27.356868193052026,10.311856287414756,24.406477046261635,28.991748616257063,22.433889738076036,0.0,22.03527707481961,24.97564042707092,23.780054128960924,22.417095286109767,26.836110103674173,25.06463202285391,26.741957480414726,25.57804638673295,24.994805438891504,25.595696873576557],[24.597438725414104,25.628637482169808,24.729942342535686,23.049066012472938,24.476775782998594,28.455813222865096,24.121530867585363,23.03853749901019,27.83277256764979,21.4438601128988,0.0,25.703581477830113,26.538122617062136,27.605215155449944,24.677365240157513,26.806967279279828,19.853359370811937,26.16949355876484,24.257027648564964,25.2920304573653],[26.002899192095867,26.1642701490498,27.8129093119746,26.459394891001576,27.995650301212606,30.936243643563383,28.622561034607177,26.322031961038952,22.118185230385436,23.634824738658295,29.52392895855612,0.0,32.14277632834517,25.09684204627193,24.99530408469395,23.792377815874907,27.184977473440405,25.08048492931936,21.645169132566895,26.56490760617831],[21.453129149828673,24.80956919052099,21.199812500252246,24.10344203563508,24.635203421394444,24.05782038763836,26.59453008055293,22.14680455032012,15.001442630049509,25.06917755726147,23.484031497085105,29.98811190454355,0.0,23.530830513077557,24.183328651202697,28.586159598483604,28.378623574700214,24.027991023086145,20.13692750844141,22.054751533838456],[17.828969733520744,21.669913707589593,24.205007511104288,22.890582943875476,24.697540859406367,26.26597447673971,22.56264600818635,26.632257051160845,26.95474253256177,23.86378642489963,23.082553540247496,25.545608125677333,19.351509201499283,0.0,27.028410739304444,23.872829325462643,27.786384268697155,27.331726955565067,20.065138996406745,23.105896892235087],[24.877330591535355,19.55686630889084,30.16930153688208,33.2183483395612,24.172467451446412,19.79457300420457,24.781311123032843,18.332941922303842,25.308810151357658,26.016228877030027,23.962420619271715,20.343445971069844,26.04123206160582,25.676921781250172,0.0,23.739860903024244,27.704194369199016,24.456014826922555,25.61933037374522,21.616969119694197],[28.680226093033774,26.522117796072294,25.59565659788624,29.281312395297903,30.175776509667116,25.89670000408237,22.019642890745715,28.45870923648588,23.038577140337114,22.929848908994405,24.932654680412586,28.617295259019784,20.719458481595392,24.75173902959818,23.63927234080289,0.0,26.823454565823564,29.160080279688618,21.74037918352905,27.94477507231305],[25.99537389027765,21.98829002223618,22.570307222493163,19.406129658584263,24.270020026836875,20.403200007425845,24.194440222830504,22.399200784527586,23.052691013204186,25.711951038434616,27.042494306671543,24.77853574351118,26.858248881915245,28.891948154950168,31.035022082602183,26.96942087860232,0.0,23.48620565229802,26.065600004390618,25.47197518380281],[25.829304328844348,29.74342021467915,25.112268168203485,19.731234316373154,15.904201969127385,23.085698593336105,25.600279395634107,28.49439224235308,25.10383856682567,22.533725437126137,25.047227545473795,24.544610736957512,25.472108722941876,22.574532169155752,20.848178739709752,19.243620717307323,24.24058646716175,0.0,18.796734461694843,21.098290974860518],[28.314753244453243,25.96559825601971,22.483582707196636,25.21031685526109,21.54027101213603,15.121735537098466,25.380301191850346,26.772369465482853,22.726637690883482,28.716677966589916,26.103695096240205,26.880090307769027,24.247146250017092,26.074499270901526,28.5793616399176,26.95672695120792,30.335408124537462,27.516196122098208,0.0,24.91222252820805],[23.570803581259405,25.19979893789796,26.298032987858562,22.578611961581387,23.406057495907234,27.113839483289155,21.12030874737679,32.61404383170628,23.890907976573438,21.160358984787912,27.245414330585973,25.129249202742177,22.04888930398412,25.22139736451934,24.209839568839364,23.701669153454986,25.724715665619783,27.186996431308263,24.667629716936485,0.0]]
#96% accurate ðŸ¤¯
ArrayOfNeurs = []
for i in range(0, num_neurons):
	
	ArrayOfNeurs.append(myNeuron(-65, -13, 0.02, 0.2, -65, 4, 0, False, exin_array[i]))

#print(ModBrain)

def dif_v(v, u, I):

	return (0.04*v**2)+(5*v)+140-u+I

def dif_u(v, u, a=0.02, b=0.2):

	return a*(b*v-u)

def step_v(NeurArray):
	for NeurIdx in range(0, len(NeurArray)):
		NeurObj = NeurArray[NeurIdx]
		NeurObj.V += dif_v(NeurObj.V, NeurObj.u, NeurObj.I)
		NeurObj.u += dif_u(NeurObj.V, NeurObj.u, NeurObj.a, NeurObj.b)
		if NeurObj.jF == True:
			NeurObj.jF = False
			NeurObj.V = NeurObj.c
			NeurObj.u = NeurObj.u + NeurObj.d
		
		if NeurObj.V >= -30:
			NeurObj.V = 30
			NeurObj.jF = True
		

		if NeurObj.V <= -70:
			NeurObj.V = -70
		

		NeurArray[NeurIdx] = NeurObj
	
	return NeurArray

def step_I(NeurArray, SynArray):
	#this formerly acted on the current input I 
	#has since been changed to act on voltage in line with the IZH paper
	for PreNeurIdx in range(0, len(NeurArray)):
		for PostNeurIdx in range(0, len(NeurArray)):
			NeurArray[PostNeurIdx].V += SynArray[PreNeurIdx][PostNeurIdx]*NeurArray[PreNeurIdx].jF*NeurArray[PreNeurIdx].exin

	return NeurArray

def zero_I(NeurArray):
	for NeurIdx in range(0, len(NeurArray)):
		NeurArray[NeurIdx].I = 0
	
	return NeurArray
	
def resetNet():

	return ArrayOfNeurs

def partialSim(time_steps, Brain, IrisIdx):
	NeurArray = copy.deepcopy(resetNet())
	allSpikes = np.zeros((num_neurons, time_steps))
	t = 0
	NeurArray = zero_I(NeurArray)
	NeurArray[0].I = train_data[IrisIdx][0][0]*curr_mult
	NeurArray[1].I = train_data[IrisIdx][0][1]*curr_mult
	NeurArray[2].I = train_data[IrisIdx][0][2]*curr_mult
	NeurArray[3].I = train_data[IrisIdx][0][3]*curr_mult
	for t in range(0, time_steps):
				
		NeurArray = step_I(NeurArray, Brain)
		NeurArray = step_v(NeurArray)

		
		for i in range(0, num_neurons):
			allSpikes[i][t] = NeurArray[i].jF
	return allSpikes

def giveSpikeSequence(time_steps, Brain):
	to_return = np.zeros((150, num_neurons, time_steps))
	for i in range(0, 150):
		to_return[i] = partialSim(time_steps, Brain, i)

	return to_return

def trackChanges(refSeq, testSeq, time_steps):
	fire_right_and_wrong = np.zeros((2, num_neurons))
	time_found = False
	max_time = time_steps
	#maybe get a more complex function to characterize which neurons contributed recently or something 
	for t in range(0, time_steps):
		if time_found:
			break
		for n in range(0, num_neurons):
			if testSeq[n][t] != refSeq[n][t] and not time_found:
				max_time = t-1
				time_found = True
				fire_right_and_wrong[1][n] = 1 #these are the incorrectly firing neurons in the test sequence

			if testSeq[n][t] == 1 and refSeq[n][t] == 1:
				fire_right_and_wrong[0][n] = 1 #these are the correctly firing neurons in the test sequence


	return fire_right_and_wrong, max_time

def targetMutt(Brain, cand_neurons, max_mutts = 150):
	num_mutts = 0
	for cand in cand_neurons:
		if num_mutts >= max_mutts:
			break
		pres = [] #presynaptic candidate neurons that fired successfully
		posts = [] #postsynaptic neurons that fired incorrectly
		for i in range(0, num_neurons):
			if cand[0][i] == 1:
				pres.append(i)
			if cand[1][i] == 1:
				posts.append(i)

		if len(pres) > 0 and len(posts) > 0:
			chosen_pre = random.choice(pres)
			chose_post = random.choice(posts)
			if chose_post != chosen_pre:
				num_mutts += 1
				Brain[chosen_pre][chose_post] = np.random.normal(Brain[chosen_pre][chose_post], 10)
				if Brain[chosen_pre][chose_post] > 50:
					Brain[chosen_pre][chose_post] = 50
				if Brain[chosen_pre][chose_post] < 0:
					Brain[chosen_pre][chose_post] = 0

	return Brain


refFires = []
for i in range(0, 150):
	refFires.append(partialSim(sim_length, ModBrain, i))

reconBrain = np.zeros((num_neurons, num_neurons))
time_steps = 10

passed = False
gen = 0
max_max_t = 0
while not passed:
	gen += 1
	partialTestFires = []
	fire_right_and_wrong_at_each_iris = np.zeros((150, 2, num_neurons))
	avg_max_t = 0
	num_perfect = 0
	for i in range(0, 150):
		partialTestFires.append(partialSim(time_steps, reconBrain, i))
		fire_right_and_wrong_at_each_iris[i], t = trackChanges(refFires[i], partialTestFires[i], time_steps)
		avg_max_t += t/150
		if t == time_steps:
			num_perfect += 1
	if avg_max_t > max_max_t:
		max_max_t = avg_max_t
		print(reconBrain)
	reconBrain = targetMutt(reconBrain, fire_right_and_wrong_at_each_iris)
	passed = np.array_equal(fire_right_and_wrong_at_each_iris, np.zeros((150, 2, num_neurons)))
	print(gen, avg_max_t, max_max_t, num_perfect)


